<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2179616395540389"
     crossorigin="anonymous"></script>
<title>Tetris — Desktop + Mobile (Single File)</title>
<style>
  :root{--bg:#071027;--panel:#0f1724;--muted:#94a3b8;--accent:#7dd3fc;--glass:rgba(255,255,255,.04)}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,#041022 0%,var(--bg)100%)}
  .app{max-width:980px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 360px;gap:16px}
  .panel{background:linear-gradient(180deg,#0d1522,#071022);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.03)}
  .play-wrap{display:flex;flex-direction:column;align-items:center;gap:8px}
  canvas#play{background:#061024;border-radius:8px;display:block}
  .hud{display:flex;gap:8px;flex-wrap:wrap}
  .stat{background:var(--glass);padding:8px;border-radius:8px;min-width:88px;text-align:center}
  .controls{display:flex;gap:8px;margin-top:8px}
  button.btn{background:transparent;border:1px solid rgba(255,255,255,.06);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer}
  .mobile-controls{display:none;position:fixed;left:0;right:0;bottom:8px;gap:12px;justify-content:center;padding:8px;z-index:40}
  .mc-btn{width:64px;height:64px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.05);display:flex;align-items:center;justify-content:center;font-size:22px;touch-action:none}
  .mc-btn:active{transform:translateY(2px)}
  .overlay{display:flex;gap:8px}
  .next-canvas{width:120px;height:120px;border-radius:8px;background:#071526}
  footer{grid-column:1/-1;margin-top:8px;color:var(--muted);font-size:12px;text-align:center}
  @media(max-width:940px){.app{grid-template-columns:1fr}.mobile-controls{display:flex}}
</style>
</head>
<body>
<div class="app">
  <div class="panel play-wrap">
    <div class="hud">
      <div class="stat"><div class="small">Score</div><div id="score">0</div></div>
      <div class="stat"><div class="small">Lines</div><div id="lines">0</div></div>
      <div class="stat"><div class="small">Level</div><div id="level">1</div></div>
      <div class="stat"><div class="small">Best</div><div id="best">0</div></div>
    </div>

    <canvas id="play" width="300" height="600" style="width:300px;height:600px"></canvas>

    <div class="controls">
      <button id="start" class="btn">Start</button>
      <button id="pause" class="btn">Pause</button>
      <button id="reset" class="btn">Reset</button>
    </div>

    <div style="margin-top:6px;color:var(--muted);font-size:13px">Клавиши: ← → • ↑/X • ↓ • Space • P (пауза). На мобильных — кнопки внизу экрана.</div>
  </div>

  <div class="panel" style="display:flex;flex-direction:column;gap:10px;align-items:stretch">
    <h2 style="margin:0">Next</h2>
    <canvas id="next" class="next-canvas" width="120" height="120"></canvas>
    <div style="display:flex;flex-direction:column;gap:8px">
      <div style="display:flex;gap:8px;align-items:center">
        <label style="display:flex;gap:6px;align-items:center"><input id="sound" type="checkbox"> sound</label>
        <label style="display:flex;gap:6px;align-items:center"><input id="ghost" type="checkbox" checked> ghost piece</label>
      </div>
      <div style="display:flex;gap:8px">
        <button id="bt-left" class="btn">← Left</button>
        <button id="bt-rot" class="btn">⟳ Rotate</button>
        <button id="bt-right" class="btn">Right →</button>
      </div>
      <div style="display:flex;gap:8px">
        <button id="bt-drop" class="btn">Soft ↓</button>
        <button id="bt-hard" class="btn">Hard Drop</button>
      </div>
    </div>
  </div>

  <footer class="panel">Single-file Tetris — desktop + mobile controls. Нужно добавить звуки, темы, или запись имени в таблицу рекордов?</footer>
</div>

<!-- Mobile controls (visible on small screens) -->
<div class="mobile-controls" id="mobileControls" aria-hidden="false">
  <div class="mc-btn" id="mc-left">◀</div>
  <div style="display:flex;gap:8px">
    <div class="mc-btn" id="mc-rot">⟳</div>
    <div class="mc-btn" id="mc-drop">↓</div>
  </div>
  <div class="mc-btn" id="mc-right">▶</div>
  <div class="mc-btn" id="mc-hard">⤓</div>
</div>

<script>
(() => {
  // config
  const COLS = 10, ROWS = 20, BLOCK = 30;
  const canvas = document.getElementById('play');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');

  const COLORS = [null,'#22c55e','#06b6d4','#f59e0b','#ef4444','#8b5cf6','#f472b6','#f97316'];

  // tetromino templates
  const T = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[2,0,0],[2,2,2],[0,0,0]],
    L:[[0,0,3],[3,3,3],[0,0,0]],
    O:[[4,4],[4,4]],
    S:[[0,5,5],[5,5,0],[0,0,0]],
    T:[[0,6,0],[6,6,6],[0,0,0]],
    Z:[[7,7,0],[0,7,7],[0,0,0]]
  };
  const PIECES = Object.keys(T);

  // state
  let arena = createMatrix(COLS, ROWS);
  let player = { pos:{x:0,y:0}, matrix:null, next:null, score:0, lines:0, level:1 };
  let dropCounter = 0, dropInterval = 1000, lastTime = 0; let running=false, paused=false;
  let ghost = true; let best = loadBest();

  // UI
  const scoreEl = document.getElementById('score'); const linesEl = document.getElementById('lines'); const levelEl = document.getElementById('level'); const bestEl = document.getElementById('best');
  bestEl.textContent = best;

  // helpers
  function createMatrix(w,h){ const m=[]; for(let y=0;y<h;y++) m.push(new Array(w).fill(0)); return m }
  function cloneMatrix(m){ return m.map(r=>r.slice()) }
  function collide(ar, pl){ const m = pl.matrix, o = pl.pos; for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++) if(m[y][x] && (ar[y+o.y] && ar[y+o.y][x+o.x])) return true; return false }
  function merge(ar, pl){ pl.matrix.forEach((row,y)=> row.forEach((val,x)=>{ if(val) ar[y+pl.pos.y][x+pl.pos.x] = val })) }
  function rotate(m, dir){ for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y],m[y][x]] = [m[y][x],m[x][y]]; if(dir>0) m.forEach(r=>r.reverse()); else m.reverse(); }

  function clearLines(){ let rowCount=0; outer: for(let y=arena.length-1;y>=0;y--){ for(let x=0;x<arena[y].length;x++) if(!arena[y][x]) continue outer; const row = arena.splice(y,1)[0].fill(0); arena.unshift(row); y++; rowCount++; } if(rowCount){ player.lines += rowCount; player.score += scoreFor(rowCount, player.level); const newLevel = Math.floor(player.lines/10)+1; if(newLevel>player.level){ player.level = newLevel; dropInterval = Math.max(100, 1000 - (player.level-1)*100); } updateStats(); } }
  function scoreFor(lines, level){ const map=[0,40,100,300,1200]; return (map[lines]||0)*level }

  function randomPiece(){ return PIECES[Math.floor(Math.random()*PIECES.length)] }
  function createPiece(type){ return cloneMatrix(T[type]) }

  function playerReset(){ player.matrix = createPiece(player.next || randomPiece()); player.next = randomPiece(); player.pos.y = 0; player.pos.x = Math.floor((COLS - player.matrix[0].length)/2); if(collide(arena, player)){ arena = createMatrix(COLS, ROWS); running=false; alert('Game Over — score: '+player.score); saveBest(player.score); best = loadBest(); bestEl.textContent = best; } drawNext(); }

  function playerDrop(){ player.pos.y++; if(collide(arena, player)){ player.pos.y--; merge(arena, player); clearLines(); playerReset(); } dropCounter = 0 }
  function playerMove(dir){ player.pos.x += dir; if(collide(arena, player)) player.pos.x -= dir }
  function playerRotate(dir){ const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir); while(collide(arena, player)){ player.pos.x += offset; offset = -(offset + (offset>0?1:-1)); if(offset > player.matrix[0].length){ rotate(player.matrix, -dir); player.pos.x = pos; return; } } }
  function hardDrop(){ while(!collide(arena, player)) player.pos.y++; player.pos.y--; merge(arena, player); clearLines(); playerReset(); dropCounter = 0 }

  function draw(){ ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); // arena
    for(let y=0;y<arena.length;y++){
      for(let x=0;x<arena[y].length;x++){
        const v = arena[y][x]; if(v){ ctx.fillStyle = COLORS[v]; ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1); }
      }
    }
    if(ghost){ drawGhost(); }
    if(player.matrix) drawMatrix(player.matrix, player.pos);
  }
  function drawMatrix(matrix, offset){ for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++){ const val=matrix[y][x]; if(val){ ctx.fillStyle = COLORS[val]; ctx.fillRect((x+offset.x)*BLOCK, (y+offset.y)*BLOCK, BLOCK-1, BLOCK-1) } } }
  function drawGhost(){ const ghostPos = {x:player.pos.x, y:player.pos.y}; while(!collisionAt(ghostPos.x, ghostPos.y+1, player.matrix)) ghostPos.y++; // draw ghost with alpha
    ctx.globalAlpha = 0.28; ctx.strokeStyle = '#ffffff'; player.matrix.forEach((row,y)=> row.forEach((val,x)=>{ if(val){ ctx.fillStyle = COLORS[val]; ctx.fillRect((x+ghostPos.x)*BLOCK, (y+ghostPos.y)*BLOCK, BLOCK-1, BLOCK-1); } })); ctx.globalAlpha = 1 }
  function collisionAt(px,py,matrix){ for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++) if(matrix[y][x] && (arena[y+py] && arena[y+py][x+px])) return true; return false }

  function drawNext(){ nextCtx.clearRect(0,0,nextCtx.canvas.width,nextCtx.canvas.height); const m = createPiece(player.next); const size = 20; const margin = 12; for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){ const v = m[y][x]; if(v){ nextCtx.fillStyle = COLORS[v]; nextCtx.fillRect(margin + x*size, margin + y*size, size-2, size-2) } } }

  function update(time=0){ if(!running || paused){ lastTime = time; requestAnimationFrame(update); return; } const delta = time - lastTime; lastTime = time; dropCounter += delta; if(dropCounter > dropInterval){ playerDrop(); } draw(); requestAnimationFrame(update); }

  function updateStats(){ scoreEl.textContent = player.score; linesEl.textContent = player.lines; levelEl.textContent = player.level }

  // storage
  function loadBest(){ try{ return parseInt(localStorage.getItem('tetris_best')||'0',10); }catch(e){ return 0 } }
  function saveBest(val){ try{ const cur = loadBest(); if(val>cur) localStorage.setItem('tetris_best', String(val)); }catch(e){} }

  // controls (desktop)
  document.getElementById('start').addEventListener('click', ()=>{ if(!running){ running=true; paused=false; player.score=0; player.lines=0; player.level=1; dropInterval=1000; player.next = randomPiece(); playerReset(); updateStats(); lastTime=0; requestAnimationFrame(update); } });
  document.getElementById('pause').addEventListener('click', ()=>{ paused = !paused; document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause'; });
  document.getElementById('reset').addEventListener('click', ()=>{ arena = createMatrix(COLS, ROWS); player.score=0; player.lines=0; player.level=1; dropInterval=1000; player.next = randomPiece(); playerReset(); updateStats(); draw(); });

  document.getElementById('bt-left').addEventListener('click', ()=>{ playerMove(-1); draw(); });
  document.getElementById('bt-right').addEventListener('click', ()=>{ playerMove(1); draw(); });
  document.getElementById('bt-rot').addEventListener('click', ()=>{ playerRotate(1); draw(); });
  document.getElementById('bt-drop').addEventListener('click', ()=>{ playerDrop(); player.score += 1; updateStats(); draw(); });
  document.getElementById('bt-hard').addEventListener('click', ()=>{ hardDrop(); updateStats(); draw(); });

  // keyboard
  window.addEventListener('keydown', e=>{
    if(!running) return;
    if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
    if(e.key === 'ArrowLeft') playerMove(-1);
    if(e.key === 'ArrowRight') playerMove(1);
    if(e.key === 'ArrowDown'){ playerDrop(); player.score += 1; }
    if(e.key === ' '){ e.preventDefault(); hardDrop(); }
    if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'x') playerRotate(1);
    if(e.key.toLowerCase() === 'p'){ paused = !paused; document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause'; }
    updateStats(); draw();
  });

  // mobile touch handlers for buttons
  const mcLeft = document.getElementById('mc-left'); const mcRight = document.getElementById('mc-right'); const mcRot = document.getElementById('mc-rot'); const mcDrop = document.getElementById('mc-drop'); const mcHard = document.getElementById('mc-hard');
  function attachTouch(el, onStart, onEnd){ let holdTimer = null; let repeating = null; el.addEventListener('touchstart', e=>{ e.preventDefault(); onStart(); // start repeat for move
    if(onStart===moveLeftStart || onStart===moveRightStart){ repeating = setInterval(onStart, 150); }
  }); el.addEventListener('touchend', e=>{ e.preventDefault(); if(repeating) clearInterval(repeating); onEnd && onEnd(); }); el.addEventListener('mousedown', e=>{ e.preventDefault(); onStart(); if(onStart===moveLeftStart||onStart===moveRightStart) repeating = setInterval(onStart,150); }); el.addEventListener('mouseup', e=>{ if(repeating) clearInterval(repeating); onEnd && onEnd(); }); }

  function moveLeftStart(){ playerMove(-1); draw(); }
  function moveRightStart(){ playerMove(1); draw(); }
  function rotStart(){ playerRotate(1); draw(); }
  function dropStart(){ playerDrop(); player.score += 1; updateStats(); draw(); }
  function hardStart(){ hardDrop(); updateStats(); draw(); }

  attachTouch(mcLeft, moveLeftStart, null);
  attachTouch(mcRight, moveRightStart, null);
  attachTouch(mcRot, rotStart, null);
  attachTouch(mcDrop, dropStart, null);
  attachTouch(mcHard, hardStart, null);

  // responsive: show mobile controls based on width
  function adjustMobileControls(){ const el = document.getElementById('mobileControls'); if(window.innerWidth <= 940){ el.style.display = 'flex'; } else { el.style.display = 'none'; } }
  window.addEventListener('resize', adjustMobileControls); adjustMobileControls();

  // init
  player.next = randomPiece(); playerReset(); draw(); drawNext(); updateStats();

  // helpers already defined above: randomPiece, drawNext, etc.
  function randomPiece(){ return PIECES[Math.floor(Math.random()*PIECES.length)] }

})();
</script>
</body>
</html>
